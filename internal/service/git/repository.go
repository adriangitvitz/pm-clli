package git

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/plumbing"
)

// GitRepository implements the domain.GitRepository interface
type GitRepository struct {
	repo *git.Repository
	path string
}

// NewGitRepository creates a new GitRepository instance
func NewGitRepository() *GitRepository {
	return &GitRepository{}
}

// IsInRepository checks if the current directory is inside a Git repository
func (g *GitRepository) IsInRepository() bool {
	repo, err := g.getRepository()
	return err == nil && repo != nil
}

// GetCurrentBranch returns the name of the current Git branch
func (g *GitRepository) GetCurrentBranch() (string, error) {
	repo, err := g.getRepository()
	if err != nil {
		return "", fmt.Errorf("failed to get repository: %w", err)
	}

	head, err := repo.Head()
	if err != nil {
		return "", fmt.Errorf("failed to get HEAD: %w", err)
	}

	if head.Name().IsBranch() {
		return head.Name().Short(), nil
	}

	// If we're in detached HEAD state, return the commit hash
	return head.Hash().String()[:8], nil
}

// GetCurrentCommit returns the hash of the current commit
func (g *GitRepository) GetCurrentCommit() (string, error) {
	repo, err := g.getRepository()
	if err != nil {
		return "", fmt.Errorf("failed to get repository: %w", err)
	}

	head, err := repo.Head()
	if err != nil {
		return "", fmt.Errorf("failed to get HEAD: %w", err)
	}

	return head.Hash().String(), nil
}

// GetRepositoryRoot returns the root directory of the Git repository
func (g *GitRepository) GetRepositoryRoot() (string, error) {
	repo, err := g.getRepository()
	if err != nil {
		return "", fmt.Errorf("failed to get repository: %w", err)
	}

	worktree, err := repo.Worktree()
	if err != nil {
		return "", fmt.Errorf("failed to get worktree: %w", err)
	}

	return worktree.Filesystem.Root(), nil
}

// CreateCommitHook creates a commit message hook that references the task ID
func (g *GitRepository) CreateCommitHook(taskID string) error {
	repoRoot, err := g.GetRepositoryRoot()
	if err != nil {
		return fmt.Errorf("failed to get repository root: %w", err)
	}

	hookPath := filepath.Join(repoRoot, ".git", "hooks", "prepare-commit-msg")

	// Create the hook script
	hookContent := fmt.Sprintf(`#!/bin/sh
# Auto-generated by Project Manager CLI
# This hook adds task reference to commit messages

COMMIT_MSG_FILE=$1
COMMIT_SOURCE=$2

# Only add task reference for regular commits (not merges, rebases, etc.)
if [ -z "$COMMIT_SOURCE" ] || [ "$COMMIT_SOURCE" = "message" ]; then
    # Check if task reference is already in the commit message
    if ! grep -q "\[Task #%s\]" "$COMMIT_MSG_FILE"; then
        # Prepend task reference to commit message
        echo "[Task #%s] $(cat $COMMIT_MSG_FILE)" > "$COMMIT_MSG_FILE"
    fi
fi
`, taskID, taskID)

	// Write the hook file
	if err := os.WriteFile(hookPath, []byte(hookContent), 0755); err != nil {
		return fmt.Errorf("failed to write commit hook: %w", err)
	}

	return nil
}

// RemoveCommitHook removes the commit message hook
func (g *GitRepository) RemoveCommitHook() error {
	repoRoot, err := g.GetRepositoryRoot()
	if err != nil {
		return fmt.Errorf("failed to get repository root: %w", err)
	}

	hookPath := filepath.Join(repoRoot, ".git", "hooks", "prepare-commit-msg")

	// Check if the file exists and was created by us
	if content, err := os.ReadFile(hookPath); err == nil {
		if strings.Contains(string(content), "Auto-generated by Project Manager CLI") {
			if err := os.Remove(hookPath); err != nil {
				return fmt.Errorf("failed to remove commit hook: %w", err)
			}
		}
	}

	return nil
}

// getRepository gets or initializes the Git repository
func (g *GitRepository) getRepository() (*git.Repository, error) {
	if g.repo != nil {
		return g.repo, nil
	}

	// Try to open repository from current directory
	wd, err := os.Getwd()
	if err != nil {
		return nil, fmt.Errorf("failed to get working directory: %w", err)
	}

	repo, err := git.PlainOpenWithOptions(wd, &git.PlainOpenOptions{
		DetectDotGit: true,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to open git repository: %w", err)
	}

	g.repo = repo
	g.path = wd

	return repo, nil
}

// GetBranches returns a list of all branches in the repository
func (g *GitRepository) GetBranches() ([]string, error) {
	repo, err := g.getRepository()
	if err != nil {
		return nil, fmt.Errorf("failed to get repository: %w", err)
	}

	branches, err := repo.Branches()
	if err != nil {
		return nil, fmt.Errorf("failed to get branches: %w", err)
	}

	var branchNames []string
	err = branches.ForEach(func(branch *plumbing.Reference) error {
		branchNames = append(branchNames, branch.Name().Short())
		return nil
	})

	if err != nil {
		return nil, fmt.Errorf("failed to iterate branches: %w", err)
	}

	return branchNames, nil
}

// GetRemoteURL returns the URL of the origin remote
func (g *GitRepository) GetRemoteURL() (string, error) {
	repo, err := g.getRepository()
	if err != nil {
		return "", fmt.Errorf("failed to get repository: %w", err)
	}

	remote, err := repo.Remote("origin")
	if err != nil {
		return "", fmt.Errorf("failed to get origin remote: %w", err)
	}

	config := remote.Config()
	if len(config.URLs) > 0 {
		return config.URLs[0], nil
	}

	return "", fmt.Errorf("no URL found for origin remote")
}

// IsClean returns true if the working directory is clean (no uncommitted changes)
func (g *GitRepository) IsClean() (bool, error) {
	repo, err := g.getRepository()
	if err != nil {
		return false, fmt.Errorf("failed to get repository: %w", err)
	}

	worktree, err := repo.Worktree()
	if err != nil {
		return false, fmt.Errorf("failed to get worktree: %w", err)
	}

	status, err := worktree.Status()
	if err != nil {
		return false, fmt.Errorf("failed to get status: %w", err)
	}

	return status.IsClean(), nil
}